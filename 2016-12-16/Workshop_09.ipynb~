{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<h1>Workshop n°9 di GGPL di Emanuele Chiossi, mat. 439468</h1>\n",
    "<h3>My roof terrace</h3>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<h2>Descrizione</h2>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "L'obiettivo dell'homework numero 9 è quello di ricreare un progetto geometrico di tetti. \n",
    "\n",
    "Si vuole produrre una funzione che, qualsiasi sia il poligono in input e l'angolo di inclinazione dei piani che lo compongono (dipendente dall'altezza a cui si pone il terrazzo), realizzi un tetto formato da falde con stessa inclinazione: tutti i piani hanno la stessa tangente con il piano orizzontale.\n",
    "\n",
    "Le funzioni di supporto suggerite in aula per risolvere questo problema geometrico sono le seguenti:\n",
    "<ul>\n",
    "<li>funzione che calcola il fascio di piani passanti per una retta: determinazione del piano di interesse in funzione dell'angolo che si vuole tra il piano orizzontale ed il piano stesso (dipendente dall'altezza a cui si pone il terrazzo, dato passato come parametro)</li>\n",
    "<li>funzione che costruisce la porzione di piano di interesse</li>\n",
    "<li>funzione che calcola l'intersezione tra porzioni di piano adiacenti</li>\n",
    "<li>funzione che determina se un angolo è concavo o convesso sulla base della funzione atan2(y,x)</li>\n",
    "<li>funzione che costruisce un piano qualsiasi dati i vertici (terrazzo)</li>\n",
    "</ul><br>\n",
    "Le funzioni utilizzate verranno approfondite una ad una più avanti."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "L'immagine di ispirazione presa dal web è la seguente:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![text alt](esempio.jpg)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Il progetto è stato realizzato step by step, in particolare:\n",
    "<ul>\n",
    "<li>la funzione createListAtan2 calcola, dati i vertici, tramite l'utilizzo della funzione atan2(y,x) della libreria math, l'arcotangente tra l'asse x e la singola retta che compone il perimetro della casa. \n",
    "Grazie a questa funzione è possibile calcolare gli angoli interni della casa date due rette consecutive, così da poter stabilire se un angolo è concavo o convesso.\n",
    "\n",
    "Le variabili principali utilizzate per questa funzione sono:\n",
    "\n",
    "<ul>\n",
    "<li>x, y: si posiziona idealmente il segmento di interesse nell'origine, si calcolano le coordinate x,y del secondo punto e si memorizzano rispettivamente nelle variabili in questione</li>\n",
    "<li>a: angolo in gradi dato dalla funzione atan2</li>\n",
    "</ul>\n",
    "</li>\n",
    "<br>\n",
    "<li>la funzione createListAngle, dati gli angoli \"atan2\", calcola gli angoli interni del perimetro, ovvero gli angoli che creano ogni coppia di segmenti consecutivi.\n",
    "La lista degli angoli è memorizzata nella variabile angles.\n",
    "</li>\n",
    "<br>\n",
    "<li>\n",
    "la funzione getConvexAngles restituisce gli indici in cui sono memorizzati gli angoli convessi nella lista degli angoli, corrispondenti al numero che identifica le coppie consecutive di segmenti che creano gli angoli di interesse.\n",
    "ConvexAngles è la variabile che memorizza la lista di indice.\n",
    "</li>\n",
    "<br>\n",
    "<li>la funzione createRoofBase crea la base del tetto, passando come parametro la lista di vertici e la lista degli angoli convessi, in relazione tra loro tramite indice. \n",
    "Per ogni vertice convesso si suddivide il piano in più celle, in modo da ottenere un insieme di celle in cui non ci sono angoli convessi.\n",
    "Le variabili principali utilizzate in questa funzione sono:\n",
    "<ul>\n",
    "<li>aaa: lista di liste, ognuna delle quali rappresenta una cella dell'MKPOL</li>\n",
    "<li>usedVertex: lista dei vertici utilizzati</li>\n",
    "<li>unusedVertex: lista dei vertici non utilizzati</li>\n",
    "</ul>\n",
    "</li>\n",
    "<br>\n",
    "<li>la funzione createPlan crea, dato un insieme di vertici ed una altezza, i piani passanti per ogni segmento del perimetro e li restituisce nella lista piani. \n",
    "Le principali variabili utilizzate in questa funzione sono:\n",
    "<ul>\n",
    "<li>v1,v2: coppia di vertici che delimitano il piano di interesse passante per lo specifico segmento</li>\n",
    "<li>v3,v4: coppia di vertici che delimitano il piano di interesse da calcolare, si predilige una forma del piano trapezioidale, così da evitare intersezioni vuote nello step successivo</li>\n",
    "<li>m: coefficiente angolare del segmento</li>\n",
    "<li>v,c,p: rispettivvamente vertici e celle da dare in pasto all'MKPOL, memorizzato in p (plan)</li>\n",
    "</ul>\n",
    "<br>\n",
    "</li>\n",
    "<li>la funzione getPlanIntersections, data la lista dei piani, calcola le intersezioni tra piani adiacienti e restituisce i punti di intersezione.\n",
    "Le variabili utilizzate in questa funzione sono:\n",
    "<ul>\n",
    "<li>intersezione: in cui si memorizza l'intersezione tra due piani</li>\n",
    "<li>modifiedAllPointsInterserction: contiene tutti i punti che costituiscono l'intersezione</li>\n",
    "<li>modifiedPointsPlan1: contiene tutti i punti che costituiscono i primo piano di interesse</li>\n",
    "<li>modifiedPointsPlan2: contiene tutti i punti che costituiscono i secondo piano di interesse</li>\n",
    "<li>pointsPlan1: punti di interesse del piano 1</li>\n",
    "<li>pointsPlan2: punti di interesse del piano 2</li>\n",
    "<li>allPointsInterserction: punti di interesse dell'intersezione</li>\n",
    "<li>internalPointIntersection: punti dell'intersezione interni</li>\n",
    "<li>meanPoint: punto medio interno</li>\n",
    "</ul>       \n",
    "</li>\n",
    "</ul>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "La funzione principale MyRoofTerrace, dati in input un perimetro e l'altezza desiderata del terrazzo, utilizza tutte le precedenti funzioni per realizzare lo scopo dell'homework. \n",
    "Nello specifico le veriabili utilizzate sono:\n",
    "<ul>\n",
    "<li>homePerimeter: variabile che rappresenta il perimetro della casa</li>\n",
    "<li>atan2: lista delle arcotangenti tra segmenti e asse x</li>\n",
    "<li>angles: lista degli angoli tra due segmenti consecutivi</li>\n",
    "<li>convexAngles: lista degli angoli convessi</li>\n",
    "<li>underRoof: variabile che rappresenta la base del tetto</li>\n",
    "<li>piani: lista delle porzioni di piano, una per segmento</li>\n",
    "<li>internalMeanPointIntersection: lista dei punti interni medi dell'intersezione</li>\n",
    "<li>partsOfRoof: lista contenente le varie falde del tetto(piani inclinati)</li>\n",
    "<li>overRoof: variabile che rappresenta il terrazzo</li>\n",
    "</ul>\n",
    "\n",
    "Ulteriori specifiche relative alle strategie implementative e al modus operandi sono espresse nel codice sotto forma di commento."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Per abbellire un poco la struttura ottenuta, sono state utilizzate delle texture. \n",
    "Nello specifico le seguenti sono state rispettivamente usate per le tegole, il terrazzo e la base del tetto:\n",
    "![text alt](tegole_15.jpg)\n",
    "![text alt](sopraTetto.jpg)\n",
    "![text alt](sottoTetto.jpg)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Il codice prodotto per questo homework è il seguente:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<pyplasm.xgepy.Hpc; proxy of <Swig Object of type 'std::shared_ptr< Hpc > *' at 0x7fc9d167d900> >"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from pyplasm import *\n",
    "from fpformat import *\n",
    "import math\n",
    "\n",
    "def createListAtan2(vertexs):\n",
    "    #utilizzo la funzione atan2 della libreria math per calcolare l'arcotangente tra l'asse x e la singola retta \n",
    "    #che compone il perimetro della casa: in questo modo, riesco a calcolare gli angoli tra rette consecutive \n",
    "    #e posso stabilire se un angolo e concavo o convesso\n",
    "    atan2 = []\n",
    "    for i in range(0,len(vertexs)-1):  \n",
    "        x = vertexs[i+1][0]-vertexs[i][0] #posiziono idealmente la retta di interesse nell'origine\n",
    "        y = vertexs[i+1][1]-vertexs[i][1]#calcolando x e y tramite sottrazione tra coordinate del vertice successivo e \n",
    "        a = math.atan2(y,x)*180/PI#coordinate del vertice attuale (precedente del successivo): converto la misura in gradi\n",
    "        if a+180<=180:#memorizzo l'angolo nella lista atan2 nella posizione corrispondente al segmento di interesse\n",
    "            atan2.append([a,a+180])\n",
    "        else:    \n",
    "            atan2.append([a,a-180])        \n",
    "    return atan2    \n",
    "\n",
    "def createListAngles(atan2):\n",
    "    #data la lista di arcotangenti, calcolata dalla funzione createListAtan2, calcolo gli angoli tra le coppie di segmenti \n",
    "    #consecutivi del perimetro\n",
    "    angles = []\n",
    "    for i in range (0,len(atan2)-1):  \n",
    "        a = atan2[i][1]-atan2[i+1][0]\n",
    "        if a < 0:\n",
    "            angles.append(a+360)\n",
    "        else: \n",
    "            angles.append(a)    \n",
    "    #ultimo elemento        \n",
    "    a = atan2[len(atan2)-1][1]-atan2[0][0]\n",
    "    if a < 0:\n",
    "        angles.append(a+360)\n",
    "    else: \n",
    "        angles.append(a)    \n",
    "    return angles\n",
    "\n",
    "def getConvexAngles(angles):\n",
    "    #restituisce gliindice in cui sono memorizzati gli angoli convessi nella lista degli angoli, corrispondenti al\n",
    "    #numero che identifica le coppie consecutive di segmenti che creano gli angoli di interesse\n",
    "    convexAngles = []\n",
    "    for i in range(0, len(angles)-1):\n",
    "        if math.fabs(angles[i])>180:\n",
    "            convexAngles.append(i+1)\n",
    "    return convexAngles\n",
    "\n",
    "def createRoofBase(vertexs, convexAngles):\n",
    "    #crea la base del tetto, passando come parametro la lista di vertici e la lista degli angoli convessi, in \n",
    "    #relazione tra loro tramite indice\n",
    "    ccc = []\n",
    "    originalVertexs = vertexs\n",
    "    del originalVertexs[-1]#elimino il vertice ridondante\n",
    "    if len(convexAngles)>0:\n",
    "        for i in convexAngles:#per ogni vertice convesso, divido il piano un insieme di sottopiani senza vertici convessi\n",
    "            if i==1:\n",
    "                ccc.append([1,2,len(originalVertexs)])\n",
    "            else:\n",
    "                ccc.append([i-1,i,i+1])\n",
    "    usedVertex =[] #mi salvo i vertici usati, quelli inclusi nei piani aggiuntivi\n",
    "    for cc in ccc[0]:\n",
    "        usedVertex.append(cc)\n",
    "    unusedVertex = []#mi salvo i vertici non usati, quelli escusi dai piani aggiuntivi\n",
    "    for i in range(1, len(originalVertexs)):\n",
    "        if i not in usedVertex:#creo più celle che costituiscono il piano, per escludere problemi nella visualizzazione \n",
    "            unusedVertex.append(i)#a causa degli angoli convessi si creano celle senza angoli convessi\n",
    "    unusedVertex.append(usedVertex[len(usedVertex)-2])\n",
    "    unusedVertex.append(usedVertex[len(usedVertex)-1])\n",
    "    ccc.append(unusedVertex)\n",
    "    return [ccc, originalVertexs]\n",
    "\n",
    "def createPlans(vertexs, h):\n",
    "    #funzione che crea, dato un insieme di vertici ed una altezza, le porzioni di piano per ogni segmento del perimetro\n",
    "    piani = []\n",
    "    for i in range(0, len(vertexs)-1):\n",
    "        v1 = vertexs[i]\n",
    "        v2 = vertexs[i+1]\n",
    "        #se la x del primo punto è minore di quella del secondo, in centro del tetto è verso su\n",
    "        if v1[0]<v2[0]:\n",
    "            m = (v2[1]-v1[1])/(v2[0]-v1[0])\n",
    "            #se la retta ha una pendenza non ripida\n",
    "            if math.fabs(m)<5:\n",
    "                v3 = [v1[0]-1,v1[1]+1]  #FIX:AGGIUNTO +-1 ALLE X PER FARE UNA FORMA DEL PIANO \\_/ PIUTTOSTO CHE |_|\n",
    "                v4 = [v2[0],v2[1]+1]  #EVITA LE INTERSEZIONI VUOTE\n",
    "            #se la pendenza è ripida\n",
    "            else:\n",
    "                if m>0:    \n",
    "                    #'m maggiore di zero: la retta sale, si diminuisce x di 1 per i nuovi punti'\n",
    "                    v3 = [v1[0]-1,v1[1]+1]\n",
    "                    v4 = [v2[0]-1,v2[1]+1]\n",
    "                else:\n",
    "                    #'m minore di zero: la retta scende, si aumenta x di 1 per i nuovi punti'\n",
    "                    v3 = [v1[0]+1,v1[1]+1]\n",
    "                    v4 = [v2[0]+1,v2[1]+1]\n",
    "        #il centro del tetto è verso giù\n",
    "        else:\n",
    "            m = -1*(v2[1]-v1[1])/(v2[0]-v1[0])\n",
    "            #se la retta ha una pendenza non ripida\n",
    "            if math.fabs(m)<5:\n",
    "                v3 = [v1[0]+1,v1[1]-1]   #FIX:AGGIUNTO +1 ALLE X PER FARE UNA FORMA DEL PIANO \\_/ PIUTTOSTO CHE |_|\n",
    "                v4 = [v2[0],v2[1]-1]\n",
    "            #se la pendenza è ripida\n",
    "            else:\n",
    "                if m>0:    \n",
    "                    #'m maggiore di zero: la retta sale, si diminuisce x di 1 per i nuovi punti'\n",
    "                    v3 = [v1[0]-1,v1[1]-1]\n",
    "                    v4 = [v2[0]-1,v2[1]-1]\n",
    "                else:\n",
    "                    #'m minore di zero: la retta scende, si aumenta x di 1 per i nuovi punti'\n",
    "                    v3 = [v1[0]+1,v1[1]-1]\n",
    "                    v4 = [v2[0]+1,v2[1]-1]\n",
    "        v = [v1,v2,v3,v4]\n",
    "        c = [[1,2,3,4]]\n",
    "        p = MKPOL([v,c,None])\n",
    "        piani.append(p)\n",
    "    piani.append(piani[0])    \n",
    "    return piani    \n",
    "\n",
    "def getPlansIntersection(piani):\n",
    "    #calcolo l'intersezione dei piani adiacenti per trovare i punti di interesse, che memorizzo e restituisco\n",
    "    internalMeanPointIntersection = []\n",
    "    for k in range(0, len(piani)-1):    \n",
    "        intersezione = INTERSECTION([piani[k],piani[k+1]])#calcolo intersezione\n",
    "        modifiedAllPointsInterserction = UKPOL(SKEL_0(intersezione))[0]#mi prendo i punti che costituiscono l'intersezione\n",
    "        modifiedPointsPlan1 = UKPOL(SKEL_2(piani[k]))[0]#mi prendo i punti che costituiscono i due piani consecutivi\n",
    "        modifiedPointsPlan2 = UKPOL(SKEL_2(piani[k+1]))[0]\n",
    "        pointsPlan1 = []\n",
    "        pointsPlan2 = []\n",
    "        allPointsInterserction = []\n",
    "        for point in modifiedPointsPlan1:#ripulisco l'insieme di punti relativi al piano 1\n",
    "            list = []\n",
    "            for i in point:\n",
    "                x = float(fix(i,3))\n",
    "                list.append(x)\n",
    "            pointsPlan1.append(list)\n",
    "        for point in modifiedPointsPlan2:#ripulisco l'insieme di punti relativi al piano 2\n",
    "            list = []\n",
    "            for i in point:\n",
    "                x = float(fix(i,3))\n",
    "                list.append(x)\n",
    "            pointsPlan2.append(list)\n",
    "        for point in modifiedAllPointsInterserction:#ripulisco l'insieme dei punti intersezione\n",
    "            list = []\n",
    "            for i in point:\n",
    "                x = float(fix(i,3))\n",
    "                list.append(x)\n",
    "            allPointsInterserction.append(list)\n",
    "        internalPointIntersection = []\n",
    "        for point in allPointsInterserction:#prendo i punti dell'itersezione che non sono in entrambi i piani di partenza\n",
    "            if point not in pointsPlan2 and point not in pointsPlan1:\n",
    "                internalPointIntersection.append(point)#questi punti sono quelli interni al perimetro\n",
    "        #calcolo il punto medio dei punti di interesse da usare come vertice interno: meanPoint\n",
    "        sommaX = sommaY = cont = 0\n",
    "        for point in internalPointIntersection:\n",
    "            sommaX = sommaX+point[0]\n",
    "            sommaY = sommaY+point[1]\n",
    "            cont = cont+1\n",
    "        meanPoint = [float(fix(sommaX/cont,3)),float(fix(sommaY/cont,3)),1]#punti interni, di interesse\n",
    "        internalMeanPointIntersection.append(meanPoint)\n",
    "    #sposto l'ultimo elemento della lista in prima posizione\n",
    "    app = internalMeanPointIntersection[-1]#metto l'ultimo elemento in testa per rispettare la corrispondenza degli indici\n",
    "    internalMeanPointIntersection.insert(0, app)#tra le varie liste\n",
    "    return internalMeanPointIntersection\n",
    "\n",
    "def my_roof_terrace(vertexs, h):\n",
    "    homePerimeter = STRUCT(AA(POLYLINE)([vertexs]))#costruzione del perimetro della casa\n",
    "    #devo capire quali degli angoli del perimetro sono concavi o convessi, uso funzione createListAtan2\n",
    "    atan2 = createListAtan2(vertexs)\n",
    "    #calcolo gli angoli tra due segmenti consecutivi e li memorizzo nella lista angles\n",
    "    angles = createListAngles(atan2)\n",
    "    #mi salvo gli angoli convessi, ovvero l'indice del punto che ha un angolo convesso, nella lista convexAngles\n",
    "    convexAngles = getConvexAngles(angles)\n",
    "    #creo la base del tetto\n",
    "    ris = createRoofBase(vertexs, convexAngles)\n",
    "    ccc = ris[0]\n",
    "    originalVertexs = ris[1]\n",
    "    underRoof = []#sottotetto, underRoof\n",
    "    underRoof.append(TEXTURE(['sottoTetto.jpg',TRUE,FALSE,1,1,0,5,5]))\n",
    "    underRoof.append(MKPOL([originalVertexs,ccc,None]))\n",
    "    #reiserisco il vertice ridondante in coda alla lista\n",
    "    vertexs.insert(len(vertexs),p1)\n",
    "    #per ogni coppia di punti adiacenti, genero un piano con MKPOL che mi servirà a capire i punti di incidenza\n",
    "    #del tetto da mettere ad altezza 1 \n",
    "    piani = createPlans(vertexs, h)\n",
    "    #calcolo l'intersezione dei piani adiacenti per trovare i punti di interesse che memorizzo: internalMeanPointIntersection\n",
    "    internalMeanPointIntersection = getPlansIntersection(piani)\n",
    "    #adesso ho la lista dei vertici del perimetro del tetto e la lista dei vertici interni per fare il terrazzo e la copertura\n",
    "    #costruisco le parti del tetto: partsOfRoof\n",
    "    overRoof = []#sottotetto, overRoof\n",
    "    overRoof.append(TEXTURE(['sopraTetto.jpg',TRUE,FALSE,1,1,0,5,5]))\n",
    "    overRoof.append(MKPOL([internalMeanPointIntersection,ccc,None]))\n",
    "    partsOfRoof = []#costruisco le varie falde del tetto\n",
    "    partsOfRoof.append(TEXTURE(['tegole_15.jpg',TRUE,FALSE,1,1,0,15,20]))\n",
    "    for i in range(0, len(vertexs)-1):#aggiungo la terza dimensione ai punti (una sola volta)\n",
    "        if len(vertexs[i])<3:\n",
    "            vertexs[i].insert(len(vertexs[i]),0)\n",
    "        if len(vertexs[i+1])<3:\n",
    "            vertexs[i+1].insert(len(vertexs[i+1]),0)\n",
    "        v = [vertexs[i],vertexs[i+1],internalMeanPointIntersection[i+1],internalMeanPointIntersection[i]]\n",
    "        c = [[1,2,3,4]] \n",
    "        partsOfRoof.append(MKPOL([v,c,None]))\n",
    "    return STRUCT([STRUCT(partsOfRoof),STRUCT(underRoof),STRUCT(overRoof)])\n",
    "    \n",
    "#parametri del perimetro del tetto\n",
    "p1 = [2.,0.]\n",
    "p2 = [6.,5.]\n",
    "p3 = [16.,2.]\n",
    "p4 = [17.,12.]\n",
    "p5 = [4.,13.]\n",
    "p6 = [1.,9.]\n",
    "\n",
    "vertexs = [p1,p2,p3,p4,p5,p6,p1]\n",
    "#richiamo funzione principale\n",
    "roofTerrace = my_roof_terrace(vertexs, 1)\n",
    "\n",
    "VIEW(roofTerrace)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<h2>Screenshot dell'oggetto HPC ottenuto: tetto con terrazza</h2>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![text alt](F1.png)\n",
    "![text alt](f2.png)\n",
    "![text alt](F3.png)\n",
    "![text alt](f4.png)\n",
    "![text alt](f5.png)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
